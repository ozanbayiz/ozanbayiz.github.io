---
title: "Fun with Filters and Frequencies!"
shortTitle: "Filters and Frequencies"
description: "Edges and DoG, unsharp masking, hybrid images, Gaussian/Laplacian stacks, multiresolution blending, and related experiments."
thumbnail: "/projects/cs180/proj2/misc/header.png"
heroImage: "/projects/cs180/proj2/misc/header.png"
gitUrl: "https://github.com/ozanbayiz/cs180"
date: "2024-09-23"
---

CS 180: Intro to Computer Vision and Computational Photography, Project 2, Fall 2024

<SectionDivider />

<a id="filters" />
## Part 1: Filters

---

<a id="finite-diff" />
### 1.1 Finite Difference Operator

To compute the gradient magnitude, I convolved the image with derivative filters, stacked the two convolved layers, and took the norm of the resultant vector.

$$
\text{img}_{D_x}  = \text{img} * D_x
$$

$$
\text{img}_{D_y} = \text{img} *D_y
$$

$$
(\text{img}_D)_{ij}
= 
\left\lVert \begin{bmatrix} (\text{img}_{D_x})_{ij} \\ (\text{img}_{D_y})_{ij} \end{bmatrix} \right\rVert _2^2 
$$

<Figure src="/projects/cs180/proj2/figures/camerman_raw_edges.png" alt="cameraman raw and edges" caption="Gradient magnitude and edges of Cameraman (finite differences)." />

I plotted the histogram of pixel intensity levels and found that most were below 0.1. A threshold of 0.14 gave the best edge map.

<Figure src="/projects/cs180/proj2/figures/hist_and_edges.png" alt="hist and edges" caption="Intensity histogram and edge map (threshold 0.14)." />

---

<a id="dog" />
### 1.2 Derivative of Gaussian

I created a Gaussian kernel using `cv2.GetGaussianKernel()`.

<Figure src="/projects/cs180/proj2/figures/blurred_cameraman.png" alt="blurred cameraman" caption="Cameraman, Gaussian kernel, and Cameraman after Gaussian blur." />

After blurring, the gradient magnitude was much less noisy, and the edges were better defined.

<Figure src="/projects/cs180/proj2/figures/blurred_hist_and_edges.png" alt="blurred hist and edges" caption="Histogram and edges after Gaussian blur." />

Convolution is associative, so blurring first and then differentiating is equivalent to convolving with the derivative of the Gaussian directly:

$$
\frac{\partial}{\partial x}(G * \text{img}) = \left(\frac{\partial G}{\partial x}\right) * \text{img}
$$

This means $D_x G$ and $D_y G$ can be precomputed and applied in a single convolution pass.

<Figure src="/projects/cs180/proj2/figures/DoG_filters.png" alt="DoG filters" caption="Derivative-of-Gaussian filters (Dx, Dy)." />

The DoG-convolved images were nearly identical. The DoG results had slightly more texture, possibly due to zero-padding differences.

<Figure src="/projects/cs180/proj2/figures/DoG_hist_edges.png" alt="DoG hist edges" caption="DoG-based histogram and edge map." />

<SectionDivider />

<a id="frequencies" />
## Part 2: Frequencies

---

<a id="unsharp" />
### 2.1 Unsharp Masking

Unsharp masking sharpens an image by amplifying its high-frequency content. Given a Gaussian low-pass filter $G$, the sharpened image is:

$$
\text{img}_{\text{sharp}} = (1 + \alpha)\,\text{img} - \alpha\,(G * \text{img}) = \text{img} + \alpha\,(\text{img} - G * \text{img})
$$

where $\alpha$ controls the sharpening strength. In filter form, the unsharp mask kernel is $(1 + \alpha)\delta - \alpha G$, where $\delta$ is the unit impulse.

<Figure src="/projects/cs180/proj2/figures/hp_lp_um_filters.png" alt="hp lp um filters" caption="High-pass, low-pass, and unsharp masking filters." />

<Figure src="/projects/cs180/proj2/figures/taj_sharpened.png" alt="taj sharpened" caption="Taj Mahal sharpened with unsharp masking." />

<Figure src="/projects/cs180/proj2/figures/noot_sharpening.png" alt="noot sharpening" caption="De Noot: sharpen, blur, sharpen sequence." />

---

<a id="hybrid-images" />
### 2.2 Hybrid Images

A hybrid image combines the low frequencies of one image with the high frequencies of another. Given images $a$ and $b$:

$$
\text{img}_{\text{hybrid}} = G_\sigma * a + (b - G_\sigma * b)
$$

where $G_\sigma$ is a Gaussian blur with cutoff controlled by $\sigma$. From far away, only the low-frequency component (from $a$) is visible; up close, the high-frequency component (from $b$) dominates.

<ImageGrid>
<Figure src="/projects/cs180/proj2/hybrids/efrostrawberry.png" alt="efrostrawberry" caption="Efrostrawberry" />
<Figure src="/projects/cs180/proj2/hybrids/hummingfros.png" alt="hummingfros" caption="Hummingfros" />
<Figure src="/projects/cs180/proj2/hybrids/strawbird.png" alt="strawbird" caption="Strawbird" />
</ImageGrid>

I separated images into high and low frequencies by computing the 2D DFT, applying a Gaussian mask to isolate the low frequencies, subtracting to obtain the high frequencies, and converting back with the inverse DFT.

<Figure src="/projects/cs180/proj2/figures/efrostrawberry_spectra.png" alt="efrostrawberry spectra" caption="Frequency spectra for the 'efrostrawberry' hybrid." />

<Figure src="/projects/cs180/proj2/hybrids/efrostrawberry_flop.png" alt="efrostrawberry flop" caption="Failed hybrid due to incorrect blend weight." />

---

<a id="stacks" />
### 2.3 Gaussian and Laplacian Stacks

The Laplacian stack captures band-pass details at each level. Given a Gaussian stack $G_0, G_1, \ldots, G_n$:

$$
L_i = G_i - G_{i+1}, \quad i = 0, \ldots, n-1
$$

$$
L_n = G_n
$$

Each $L_i$ contains the frequencies present at scale $i$ that are absent at scale $i+1$. The last level $L_n$ is the residual low-frequency content.

I constructed the Gaussian stack using a series of Gaussian masks with $\sigma_i = \min(h,w) \times 2^{-i}$, each scaled so that the maximum value was 1.

<Figure src="/projects/cs180/proj2/figures/gauss_mask.png" alt="gauss mask" caption="Gaussian masks across scales." />

<Figure src="/projects/cs180/proj2/figures/apple_orange_gl_stacks.png" alt="apple orange gl stacks" caption="Gaussian and Laplacian stacks for the apple/orange example." />

---

<a id="blending" />
### 2.4 Multiresolution Blending

Using the Gaussian and Laplacian stacks:

1. Compute the Laplacian stack for both images, $L_{im_1}, L_{im_2}$.
2. Create a mask and compute its Gaussian stack, $G_m$.
3. Blend:
$$
\text{img}_{\text{blended}} = \sum_{i=0}^{n} (L_{im_1})_i \times (G_m)_i + (L_{im_2})_i \times (1-(G_m)_i)
$$

<Figure src="/projects/cs180/proj2/blends/oraple.png" alt="oraple" caption="Multiresolution blend: the 'Oraple'." />

<ImageGrid>
<Figure src="/projects/cs180/proj2/blends/noot_with_hat.png" alt="noot with hat" caption="Noot with Hat" />
<Figure src="/projects/cs180/proj2/blends/ozan_lecture.png" alt="ozan lecture" caption="Ozan in lecture" />
</ImageGrid>
